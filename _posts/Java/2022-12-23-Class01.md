---
categories: Coding	
tag: Java
---

# 2022. 12. 22. ~ 2022. 12. 23. 수업내용 정리

## 변수, 상수 및 타입.. 주석.. 연산자.. 기타..

<br>

# 변수, 상수 및 타입

## 1. 변수(Variable)
* 변수(Variable)는 변할수 있는 수(값)를 의미한다. 
> ```text
> [타입] [변수 이름];
> ``` 
> 혹은
> ```text
> [타입] [변수 이름] = [초기 값];
> ``` 
> 형태로 선언(Declare)할 수 있다.
* 명명법(Naming Convention)으로 카멜 케이스(Camel Case, 소문자로 시작하고, 단어간 구분을 대문자로 하는 명명법)를 사용해야 한다.
* 변수의 이름은 명사(Noun)이어야 하고(일반적으로 단수, 배열은 복수), 논리(Boolean)타입일 경우 `is형용사` 혹은 `is동명사`, `동명사` 이거나 3인칭 단수의 동사(Verb)인 것이 좋다.
* 키워드(Keyword)를 이름으로 사용할 수 없다.
* 메서드 내에서, 동일하거나 보다 상위의 스코프(Scope)에서 이미 사용된 이름을 사용할 수 없다.
* 선언된 지역 변수의 값이 초기화되어 있지 않은 경우 값 대입을 제외한 그 어떤 접근도 할 수 없다. (값이 없는 상황)
* 선언된 멤버 변수의 값이 초기화되지 않은 경우 숫자(정수, 실수 전부)의 경우 0으로, `boolean`의 경우 `false`로, `char`의 경우 빈 값으로 초기화가 이루어진다.
* 지역 상수의 경우 선언과 동시에 값 초기화를 해줄 필요가 없지만, 멤버 상수의 경우 선언과 동시에 값 초기화가 이루어지지 않으면 안 된다.
### 1-1. 변수의 종류
* 지역 변수(Local Variable) : 메서드 내부에 만들어져 있는 변수를 의미한다. 메서드 실행 종료시 다시는 접근할 수 없는 변수들이고, 1회성이 강하다.
* 멤버 변수(Member Variable) : 클래스가 바로 가지고 있는 변수를 의미한다. 클래스 객체화시 해당 클래스에 대한 접근점이 사라지지 않는다면 영원히 존재하는 변수들이고, 지속성이 강하다.
* 매개 변수(Parameter) : 메서드를 정의할때 해당 메서드가 전달 인자로 받을 값의 변수 타입을 나열한 것이다.

### 1-2. 멤버 변수
* 멤버 변수(Member Variable)는 클래스가 직접 가지고 있는 변수로, 아래와 같이 선언할 수 있다.
  > ```java
  > [접근 제한자] [static]? [final]? [타입] [이름];  
  > ```
  > 혹은
  > ```java
  > [접근 제한자] [static]? [final]? [타입] [이름] = [초기 값];   
  > ```

<br><br>
## 2. 상수(Constant)
* Java 언어에 상수는 엄밀히 얘기하면 존재하지 않고, 읽기 전용(Read-Only) 개념이다.
* 값이 어떠한 변수에 대입된 후 다시 변경될 수 없는 것들을 의미한다.
> ```text
> final [타입] [변수 이름];
> ``` 
> 혹은
> ```text
> final [타입] [변수 이름] = [초기 값];
> ``` 
> 형태로 선언(Declare)할 수 있다. 단, 멤버 상수(Member Constant)는 선언과 동시에 값 초기화가 이루어지거나 생성자(Constructor)를 통해 값을 대입해야만 한다.

<br><br>
## 3. 타입(Type)
### 3-1. 기초 타입(원시 타입, Primitive Type)
* `byte` : 정수(Byte) 타입으로, -128 부터 127 까지의 정수를 가질 수 있다.
* `short` : 정수(Short Integer) 타입으로, -32,768 부터 32,767 까지의 정수를 가질 수 있다.
* `int` : 정수(Integer) 타입으로, -2,147,483,648 부터 2,147,483,647 까지의 정수를 가질 수 있다.
* `long` : 정수(Long Integer) 타입으로, -9,223,372,036,854,775,808 부터 9,223,372,036,854,775,807 까지의 정수를 가질 수 있다. 접미어(Suffix)로 `L`을 사용한다.
* `boolean` : 논리(Boolean) 타입으로 참(`true`)과 거짓(`false`)만 그 값으로 가질 수 있다.
* `char` : 문자(Character) 타입으로, 문자 한 개만 가질 수 있다. 단, 값을 가지지 않을 수 없다. 문자 표시를 위해 홑따옴표(') 특수 기호를 이용해야 한다.
* `float` : 실수(Float) 타입으로, -1.40239846와 10의 45승의 곱 부터 3.40282347와 10의 38승의 곱 까지의 값을 가질 수 있다. 단, 메모리를 아끼기 위한 특수한 조치 때문에 소수점 끝자리가 유실되거나 이에 오류(Margin Error)가 발생할 수 있어 잘 사용하지 않는다. 접미어로 `F`를 사용한다.
* `double` : 실수(Double) 타입으로, -4.94065645841246544와 10의 324승의 곱 부터 1.79769313486231570와 10의 308승의 곱 까지의 값을 가질 수 있다. 마찬가지로 오류가 발생할 수 있지만 미미함으로 대부분의 경우에는 무시하고 사용한다. 접미어로 `D`를 사용하거나 생략한다.

### 3-2. 참조 타입(Reference Type)
* `String` : 문자열(String) 타입으로, 문자 여러개를 가질 수 있다. 문자열 표시를 위해 쌍따옴표(") 특수 기호를 이용해야 한다.

<br><br>
## 4. 배열(Array)
* 배열은 어떠한 동일한 타입에 대해 하나의 변수에 여러개의 값(객체)을 가지게 하기위해 사용한다.
* 배열이 가지는 각 인자는 번호를 가지며 그 번호는 반드시 0 부터 시작한다.
* 배열의 타입으로 사용하고자 하는 타입 뒤에 대괄호(`[]`)를 붙여 이가 어떠한 타입에 대한 배열임을 알린다.
* 배열의 초기화는 **길이 초기화** 혹은 **인자 초기화** 두 방식 중 하나를 이용해야 하며 두 방식을 동시에 이용할 수 없다.
* 배열은 한번 초기화되었을 때 그 길이가 지정되고 다시 초기화하지 않는 이상 그 길이를 줄이거나 늘릴수 없다.
  > ```java
  > T[] ts;
  > ```
  > 위와 같이 선언하고 가령 정수 배열을 선언하고자 할때는 아래와 같이 선언한다.
  > ```java
  > int[] numbers;
  > ``` 
  > `int[]` 타입은 정수가 아닌 정수 배열로, `numbers` 변수는 정수 여러개를 가질 수 있다.
### 4-1. 길이 초기화
* 배열의 길이를 지정하여 초기화하는 방식으로, 이 배열이 가질 수 있는 인자의 개수를 지정하는 방식이다.
  > ```java
  > T[] ts = new T[x];
  > ```
  > 위 코드에서 변수 `ts`는 `T` 타입의 값(객체)를 `x`개 만큼 가질 수 있다는 의미이다.
  > ```java
  > int[] numbers = new int[10];
  > ```
  > 위 코드에서 변수 `numbers`는 10개의 정수를 가질 수 있는 배열 임을 의미한다.
### 4-2. 인자(요소) 초기화
* 배열의 길이를 지정하지 않고 초기화시 배열이 가지는 인자를 직접 전달하는 방식이다. 인자를 직접 전달할 때에는 길이를 명시하지 않음에 유의한다.
  > ```java
  > T[] ts = new T[] {a, b, c, ...};
  > ```
  > 위 코드에서 변수 `ts`는 `T` 타입의 값(객체)인 `a`, `b` 및 `c`를 가지는 `T`타입의 배열이다.
  > ```java
  > int[] odds = new int[] {1, 3, 5, 7, 9};
  > ```
  > 위 코드에서 변수 `odds`는 `1`, `3`, `5`, `7` 및 `9` 총 다섯개의 인자를 가지는 정수형 배열이다. 마찬 가지로 위 코드는 아래와 같이 간략하게 작성할 수 있다.
  > ```java
  > int[] odds = {1, 3, 5, 7, 9};
  > ```
### 4-3. 요소 접근
* 어떠한 배열이 가지고 있는 요소에 접근할때에는 **배열 요소 연산자**를 사용하여 접근하고자 하는 요소의 번호(인덱스)를 제공하여 접근할 수 있다.
  > ```java
  > T[] ts = new T[] {a, b, c};
  > ```
  > 위 코드에서 `b` 요소에 접근하기 위해서는 아래와 같이 작성한다.
  > ```java
  > ts[1]
  > ``` 
  > 주의할 점은 배열의 요소가 가지는 번호는 항상 `0`번 부터 시작함으로 위와 같이 두 번째 요소에 접근하기 위한 번호는 `1`번이 된다.
### 4-4. 길이 속성 `length`
* 어떠한 배열이 가지고 있는 요소들의 개수인 속성이다.
  > ```java
  > T[] ts = new T[10];
  > System.out.println( ts.length ); // 10
  > ```
* 위와 같이 어떠한 배열의 `length` 속성은 이 배열이 가지고 있는 요소의 개수를 의미함으로 어떠한 배열이 가지고 있는 **마지막 요소의 번호**(인덱스)는 항상 어떠한 배열의 **`length` 값에서 `1`을 뺀 값**이다.

<br><br><br><br><br>

# 주석
* 주석(Comment)은 코드 내에서 설명을 적기 위해 사용한다.
* 한 줄 주석은 `//`로 작성한다.
* 여러 줄 주석은 `/*`로 시작하고 `*/`로 끝낸다.
> ```java
> // 한 줄 주석
> 
> /*
> 여러
> 줄
> 주석
> */
> ```
* 주석은 코드 실행이나 성능에 영향을 미치지 않음으로 필요시 적절히 작성한다.

<br><br><br><br><br>

# 연산자
* 연산자(Operator)는 하나 이상의 값(들)을 연산하기 위해 사용한다.
* 아래 우선 순위(숫자가 낮을 수록 높은 우선 순위)에 따라 차례로 연산된다.
* 동일한 타입끼리 연산이 가능하며, 두 피연산자의 타입이 다를 경우 자동 형변환이 가능한 경우에만 연산할 수 있다.

1. 괄호 `(, )`로 특정 연산을 묶어낼 경우 우선 순위를 무시하고 우선 연산한다.<br><br>
2. 배열 요소 연산자 `[]` : 배열 요소 연산자 `[]`는 `a[x]` 꼴에서 `a`배열의 `x`번째 요소이다.<br><br>
3. 객체 멤버 연산자 `.` : 객체 멤버 연산자 `.`은 `a.b` 꼴에서 `a` 객체의 멤버 `b`에 접근한 것이다.  <br><br>
4. 전위 증가 연산자 `++` : 증가 연산자 `++`는 `++a` 꼴에서 `a`에 1을 더한다. 단, 전위 증가 연산자는 해당 구문이 실행되기 전 연산을 마친다.<br><br>
5. 전위 감소 연산자 `--` : 감소 연산자 `--`는 `--a` 꼴에서 `a`에 1을 뺀다. 단, 전위 감소 연산자는 해당 구문이 실행되기 전 연산을 마친다.<br><br>
6. 후위 증가 연산자 `++` : 증가 연산자 `++`는 `a++` 꼴에서 `a`에 1을 더한다. 단, 후위 증가 연산자는 해당 구문의 실행이 끝난 뒤 연산한다.<br><br>
7. 후위 감소 연산자 `--` : 감소 연산자 `--`는 `a--` 꼴에서 `a`에 1을 뺀다. 단, 후위 감소 연산자는 해당 구문의 실행이 끝난 뒤 연산한다. <br><br>
8. 양의 부호 연산자 `+` : 부호 연산자 `+`는 `+a` 꼴에서 `a`를 양수인 것으로 한다.<br><br>
9. 음의 부호 연산자 `-` : 부호 연산자 `-`는 `-a` 꼴에서 `a`를 음수인 것으로 한다. 단, `a`가 음수인 경우 양수로 한다.<br><br>
10. 논리 부정(반전) 연산자 `!` : 논리 부정 연산자 `!`는 `!a` 꼴에서 `a`를 부정(반전)한다.<br><br>
11. 객체 생성 연산자 `new` : 객체 생성 연산자 `new`는 `new T` 꼴에서 `T` 타입을 객체화한 객체이다.<br><br>
12. 형 변환 연산자 `(T)` : 형 변환 연산자 `(T)`는 `(T) a` 꼴에서 `a`의 타입을 `T`로 변환한다. <br><br>
13. 곱하기 산술 연산자 `*` : 산술 연산자 `*`는 `a * b` 꼴에서 `a`와 `b`를 곱한 값이다.
14. 나누기 산술 연산자 `/` : 산술 연산자 `/`는 `a / b` 꼴에서 `a`를 `b`로 나눈 몫이다.
15. 나머지 산술 연산자 `%` : 산술 연산자 `%`는 `a % b` 꼴에서 `a`를 `b`로 나눈 나머지이다. (`*`, `/` 및 `%`는 동률의 우선 순위를 가진다.)<br><br>
16. 더하기 산술 연산자 `+` : 산술 연산자 `+`는 `a + b` 꼴에서 `a`와 `b`를 더한 값이다. 만약 피연산자 중 한 개 이상이 문자열(`String`) 타입인 경우 문자열 합치기(String Concatenation)를 수행한다. 이는 문자열이 아닌 다른 어떠한 값을 문자열로 변환하여 문자열과 문자열을 이어 붙이는 것과 동일하다.
17. 빼기 산술 연산자 `-` : 산술 연산자 `-`는 `a - b` 꼴에서 `a`에서 `b`를 뺀 값이다. (`+`와 `-`는 동률의 우선 순위를 가진다.)<br><br>
18. 초과 비교 연산자 `>` : 비교 연산자 `>`는 `a > b` 꼴에서 `a`가 `b`보다 큰가에 대한 여부이다.
19. 미만 비교 연산자 `<` : 비교 연산자 `<`는 `a < b` 꼴에서 `a`가 `b`보다 작은가에 대한 여부이다.
20. 이상 비교 연산자 `>=` : 비교 연산자 `>=`는 `a >= b` 꼴에서 `a`가 `b` 이상인가에 대한 여부이다.
21. 이하 비교 연산자 `<=` : 비교 연산자 `<=`는 `a <= b` 꼴에서 `a`가 `b` 이하인가에 대한 여부이다. (`>`, `<`, `>=` 및 `<=`는 동률의 우선 순위를 가진다.)<br><br>
22. `instanceof` 연산자 : `instanceof` 연산자는 `a instanceof T` 꼴에서 객체 `a`가 `T` 타입으로 형변환 될 수 있는가의 여부이다.<br><br>
23. 동등 비교 연산자 `==` : 비교 연산자 `==`는 `a == b` 꼴에서 `a`와 `b`의 (스택)값이 같은가에 대한 여부이다.
24. 부등 비교 연산자 `!=` : 비교 연산자 `!=`는 `a != b` 꼴에서 `a`와 `b`의 (스택)값이 다른가에 대한 여부이다. (`==` 및 `!=`는 동률의 우선 순위를 가진다.) <br><br>
25. AND 논리 연산자 `&&` : 논리 연산자 `&&`는 `a && b` 꼴에서 `a`와 `b`가 모두 참(`true`)인가에 대한 여부이다. <br><br>
26. OR 논리 연산자 `||` : 논리 연산자 `||`는 `a || b` 꼴에서 `a`와 `b`중 하나 이상이 참(`true`)인가에 대한 여부이다. <br><br> 
27. 삼항 연산자 `... ? ... : ...` : 삼항 연산자 `... ? ... : ...`는 `a ? t : f` 꼴에서 `a`가 참이면 `t`를, 거짓이면 `f`이다. <br><br>
28. 대입 연산자 `=` : 대입 연산자 `=`는 `a = b` 꼴에서 `b`의 값을 `a`에 대입한다. <br><br>
29. 더하기 복합 대입 연산자 `+=` : 대입 연산자 `+=`은 `a += b` 꼴에서 `a`에 `b`를 더한 뒤 `a`에 대입한다. `a = a + b` 꼴과 같다.
30. 빼기 복합 대입 연산자 `-=` : 대입 연산자 `-=`은 `a -= b` 꼴에서 `a`에서 `b`를 뺀 뒤 `a`에 대입한다. `a = a - b` 꼴과 같다.
31. 곱하기 복합 대입 연산자 `*=` : 대입 연산자 `*=`은 `a *= b` 꼴에서 `a`와 `b`를 곱한 뒤 `a`에 대입한다. `a = a * b` 꼴과 같다.
32. 나누기 복합 대입 연산자 `/=` : 대입 연산자 `/=`은 `a /= b` 꼴에서 `a`를 `b`로 나눈 몫을 `a`에 대입한다. `a = a / b` 꼴과 같다.
33. 나머지 복합 대입 연산자 `%=` : 대입 연산자 `%=`은 `a %= b` 꼴에서 `a`를 `b`로 나눈 나머지를 `a`에 대입한다. `a = a % b` 꼴과 같다. (`=`, `+=`, `-=`, `*=`, `/=` 및 `%=`는 동률의 우선 순위를 가진다.) <br><br>

<br><br><br><br><br>

# 기타

## 명명법(Naming Convention)
* 카멜 케이스(Camel Case) : 소문자로 시작하고 단어간 구분을 대문자로 하는 명명법. 가령, `someMethod`, `someVariable`, `camelCase` 등.
    > Java에서 메서드, 매개 변수, 지역 변수, 멤버 변수의 이름에 사용된다.
* 파스칼 케이스(Pascal Case) : 대문자로 시작하고 단어간 구분을 대문자로 하는 명명법. 가령, `SomeClass`, `SomeEnumeration`, `PascalCase` 등.
    > Java에서 클래스, 열거형, 인터페이스, 어노테이션의 이름에 사용된다.
* 케밥 케이스(Kebab Case) : 전체 소문자이고 단어간 구분을 대쉬(-)로 하는 명명법. 가령, `some-class`, `some-id`, `some-attribute` 등.
    > Java에서 사용되지 않음.
* 스네이크 케이스(Snake Case) : 전체 소문자이고 단어간 구분을 언더스코어(_)로 하는 명명법. 가령, `some_name`, `some_php`, `some_thing` 등.
    > Java에서 사용되지 않음.
* 어퍼 스네이크 케이스(Upper Snake Case) : 전체 대문자이고 단어간 구분을 언더스코어(_)로 하는 명명법. 가령, `SOME_NAME`, `SOME_THING`, `SOME_CONST` 등.
    > Java에서 정적이고 읽기 전용인(`static final`) 멤버 변수, 열거형 인자의 이름에 사용된다. 단, 정적이고 읽기 전용인 대상 중 그 값이 리터럴(Literal)이지 않고 객체인 경우 카멜 케이스를 사용하기도 한다.

<br><br>
## 표현식(Expression)
* 어떠한 값이나 변수, 혹은 메서드의 호출 결과 간의 연산을 하는 것(코드 조각)을 의미한다.
* 구문에 포함되는 개념이다.

<br><br>
## 구문(Statement)
* 표현식(들)으로 이루어진 하나의 코드 실행 단위이다.
* 세미콜론(`;`)으로 끝내야만 한다.

<br><br>
## 블록(Block)
* 코드(들) 혹은 구문(들)의 집합이다.
* 중괄호(`{` 및 `}`)로 감싼다.

<br><br>
## 패키지(Package)
* 클래스를 포함하는 구성요소 등이 존재하는 위치이다.
* 가령, 클래스 `First`가 `a.b.c`라는 패키지 경로 아래에 있다면 해당 클래스의 풀 네임은 `a.b.c.First`가 된다.
* 패키지는 실질적으로 디렉토리이며 각 디렉토리간의 구분을 마침표(`.`)로 한다.
* 패키지 경로의 시작은 반드시 본인이 소유하고 있는 도메인의 역순이어야 한다. 가령, `mydomain.com`이라는 도메인을 소유하고 있다면 패키지의 시작은 `com.mydomain`이어야 한다. 전통적으로는 그 뒤에 프로젝트의 이름이 온다.
* 패키지의 명명에는 카멜케이스 혹은 스네이크 케이스를 이용한다. 간혹 단어 구분 없이 전체 소문자로 작성하는 경우도 있음으로 회사의 방침에 따른다.

<br><br>
## 접근 제한자(Access Modifier)
* 접근 제한자(Access Modifier)는 어떠한 대상(클래스, 메서드 등)에 접근할 수 있는 주체를 제한하기 위해 사용한다.
1. `public` : 해당 대상에 대한 접근에 제한이 없다. (아무나 어디서든 접근 가능)
2. `protected` : 같은 패키지 경로에 있거나, 상속 관계일때만 접근할 수 있다.
3. `(default)` : 같은 패키지 경로에 있을때만 접근할 수 있다. (실제로 `default`라고 적는 것이 아니라, 접근 제한자를 생략하면 `default` 접근 제한자가 되는 것.)
4. `private` : 같은 객체(클래스 등) 내에서만 접근할 수 있다.

<br>
<br>
<br>
<br>
<br>
<br>
