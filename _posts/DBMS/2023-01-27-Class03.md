---
categories: Coding	
tag: DBMS
---

# 2023. 01. 27. 수업내용 정리

## 레코드.. 연산자..

<br>

# 레코드
* 레코드(Record)는 테이블에 소속된 실제 데이터를 의미한다. 
* 레코드 하나는 하나의 행을 의미한다.

<br>

## 삽입하기
* 테이블에 리코드를 추가하는 것을 삽입(Insert)이라고 한다. 
    >```mysql
    >INSERT INTO `스키마`.`테이블` ([`대상 열`,...]) VALUES (값,...);
    >```
    >* 위 쿼리에서 콤마로 구분한 한 개 이상의 대상 열의 순서에 맞게 콤마로 구분한 값 한 개 이상이 순서에 맞게 쌍을 이뤄야한다.
    >* 하나의 `INSERT` 쿼리로 여러 레코드를 한 번에 삽입하기 위해 아래와 같이 콤마로 구분하여 값 세토(SET)를 여러개 작성할 수 있다.
    >```mysql
    >INSERT INTO `스키마`.`테이블` ([`대상 열`,...]) VALUES
    >   (값,...),
    >   (값,...),
    >   (값,...), ...;
    >```

<br>

## 조회하기
* 테이블에 존재하는 레코드를 조회(선택)하기 위해 아래와 같이 명령한다.
  >```mysql
  >SELECT [ALL | DISTINCT]?  `열 이름,...`
  >FROM `스키마`.`테이블`
  >[JOIN]
  >[WHERE [조건]]?,
  >[GROUP BY `통계 취합 기준 열`,... [HAVING [통계에 의한 각 결과의 조건]]?]?
  >[ORDER BY `정렬 기준 열`,... [ASC|DESC]?]?
  >LIMIT [레코드 개수]?;
  >```
  >* 조회하고자 하는 열 이름을 명시하지 않고 전체 열을 순서대로 조회하기 위해 열 이름 대신 `*`로 대신할 수 있다. (실무에선 잘 안 씀)
  >* `WHERE` : 레코드를 선택하는 기준을 주기위해 사용한다. 기술된 조건에 부합하는 레코드만 선택된다. 
  >* `GROUP BY` : 통계 함수(가령 `COUNT()`, `AVG()` 등)를 사용할 때 묶어낼 레코드를 묶어낼 때 참고할 값을 가지는 기준 열을 나열한다. `GROUP BY` 없이 통계 함수를 사용할 경우 `SELECT`에 의해 선택되는 레코드 전체를 통계 대상으로 한다.  
  >* `ORDER BY` : 레코드 선택 결과를 후행하는 `정렬 기준 열`이 가지는 값에 따라 정렬하고자 할 때 사용한다. 생략시 기본키(Primary Key)가 있다면 기본키 기준 오름차순 정렬을, 없다면 삽입한 순서대로 선택된다. 
  >  * `ASC` : 오름차순 정렬(Ascending, 생략 시 기본 값)
  >  * `DESC` : 내림차순 정렬(Descending)
  >* `LIMIT` : 선택할 레코드의 개수를 제한한다. 생략시 선택 결과를 제한하지 않고 전체 결과를 반환한다.
  
<br>

  ## Join
  * `JOIN`은 `SELECT`를 하고 있는 대상 테이블이 가지고 있지 않은 데이터를 다른 테이블에서 가져오기위해 사용한다.
  * 주로 외래 키 관계인 것들 간에 `JOIN`을 하지만, 반드시 그렇게 해야하지는 않다.
  * `JOIN`을 위한 구조는 아래와 같다. 
    >```mysql
    >[LEFT|RIGHT|INNER] JOIN `대상 스키마`.`대상 테이블` ON [JOIN 조건]
    >```
    >* `LEFT JOIN` 혹은 `LEFT OUTER JOIN` : `JOIN` 키워드를 대상으로 왼쪽(`SELECT` 대상인 테이블)이 가지는 데이터를 기준으로 한다. 
    >* `RIGHT JOIN` 혹은 `RIGHT OUTER JOIN` : `JOIN` 키워드를 대상으로 오른쪽(`JOIN` 대상인 테이블)이 가지는 데이터를 기준으로 한다. 
    >* `INNER JOIN` : `SELECT`   대상인 테이블과 `JOIN` 대상인 테이블이 모두 가지고 있는 데이터를 기준으로 한다. 
    >* `CROSS JOIN` : 생략
    >* `Full Outer Join` : MariaDB는 Full Outer Join을 지원하지 않음으로 두 `SELECT` 결과를 `UNION` 하여 결합한다. 

<br>

  ## Union
  * `UNION`은 열의 개수가 같은 두 `SELECT`의 결과를 하나로 합치기 위해 사용한다. 두 `SELECT`가 가지는 열의 개수가 상이할때에는 사용할 수 없음으로 유의한다. 

<br>

  ## Sub Query
  * 서브쿼리(Sub Query)는 현재 `SELECT`하고 있는 열로써 새로운 `SELECT`를 하기위해 사용한다.
  * 서브쿼리의 결과는 반드시 한 개의 열을 가지고 있어야 한다. 
  * 사용하기는 편리하지만 `JOIN`보다 속도가 느림으로 불가피한 상황이 아니면 사용하지 않는다.

<br>

## 수정하기
* 레코드를 수정하기 위해 아래와 같이 명령한다.
  >```mysql
  >UPDATE `스키마`.`테이블`
  >SET [`값을 변경할 열 이름` = [새로운 값]],...
  >```
  >위 명령어는 해당 테이블의 모든 레코드의 열 값을 수정하겠다는 의미임으로 임의로 안전 장치를 해제하지 않는 이상 실행되지 않는다. 아래와 같이 수정하고자 하는 레코드를 특정지을 수 있는 별도의 조건을 부여해야만 한다.
  >```mysql
  >UPDATE `스키마`.`테이블`
  >SET[`값을 변경할 열 이름` = [새로운 값]],...
  >``` 
  >조건에 부합하는 레코드 중 수정될 레코드의 개수를 아래와 같이 `LIMIT` 키워드를 이용하여 제한할 수 있다.
  >```mysql
  >UPDATE `스키마`.`테이블`
  >SET [`값을 변경할 열 이름` = [새로운 값]],...
  >WHERE [조건]
  >LIMIT [개수];
  >``` 

<br>

## 삭제하기
* 레코드를 삭제하기 위해 아래와 같이 명령한다.
  >```mysql
  >DELETE FROM `스키마`.`테이블 이름`;
  >```
  >위 명령어는 해당 테이블의 모든 레코드를 삭제하겠다는 의미임으로 임의로 안전 장치를 해제하지 않는 이상 실행되지 않는다. 아래와 같이 삭제하고자 하는 레코드를 특정지을 수 있는 별도의 조건을 부여해야만 한다. 
  >```mysql
  >DELTE FROM `스키마`. `테이블`
  >WHERE [조건];
  >``` 
  >조건에 부합하는 레코드 중 삭제될 레코드의 개수를 `LIMIT` 키워드를 이용하여 아래와 같이 제한할 수 있다. 
  >```mysql
  >DELETE 
  >FROM `스키마`,`테이블`
  >WHERE [조건]
  >LIMIT [개수];
  >``` 
 
 
<br><br><br><br>
 
 # 연산자

## 비교 연산자
* `=` : `a = b` 끝에서 `a`와 `b`가 같은가의 여부이다.
  * 단, `=` 비교는 대소문자 구분을 하지 않기 때문에 비교 대상 두 개 중 하나 이상에 `BINARY` 키워드를 선행하게 하여 비교해야한다. 가령 `BINARY a = BINARY b`.
* `!=` 혹은 `<>` : `a != b` 혹은 `a <> b` 꼴에서 `a`와 `b`가 다른가의 여부이다. 
* `>` : `a > b` 꼴에서 `a`가 `b`보다 큰가에 대한 여부이다.
* `<` : `a < b` 꼴에서 `a`가 `b`보다 작은가에 대한 여부이다.
* `>=` : `a >= b` 꼴에서 `a`가 `b` 이상인가에 대한 여부이다. 
* `<=` : `a <= b` 꼴에서 `a`가 `b` 이하인가에 대한 여부이다.

<br>

## 논리 연산자
* `&&` 혹은 `AND` : `a && b` 혹은 `a AND b` 꼴에서 `a`와 `b`가 모두 참인가에 대한 여부이다. 
* `||` 혹은 `OR` : `a || b` 혹은 `a OR b` 꼴에서 `a`, `b`중 하나가 참인가에 대한 여부이다.

<br>

## 사칙 연산자
* `+` : `a + b` 꼴에서 `a`와 `b`의 합이다.
* `-` : `a - b` 꼴에서 `a`에서 `b`를 뺀 값이다. 
* `*` : `a * b` 꼴에서 `a`와 `b`를 곱한 값이다. 
* `/` : `a / b` 꼴에서 `a`를 `b`로 나눈 값이다. 
* `%` 혹은 `MOD` : `a % b` 혹은 `a MOD b` 꼴에서 `a`를 `b`로 정수부까지 나눈 나머지이다.

<br>

## 기타 연산자
* `IN` : `a IN (b, ...)` 꼴에서 `a`가 후행하는 값들의 나열에 포함되는가의 여부를 반환한다. 가령, `1 IN (1, 2, 3)` 은 `TRUE` 이다.
* `NOT IN` : `a NOT IN (b,....)` 꼴에서 `a`가 후행하는 값들의 나열에 포함되지 않는가의 여부를 반환한다. 
* `BETWEEN ... AND ...` : `a BETWEEN b AND c` 꼴에서 `a`가 `b`이상, `c` 이하인가의 여부를 반환한다. 가령, `1 BETWEEN 1 AND 3`은 `TRUE`이다.
* `NOT BETWEEN ... AND ... ` : `a NOT BETWEEN b AND c` 꼴에서 `a`가 `b`이상, `c`이하의 범위 내에 있지 않은가의 여부이다. 
* `IS NULL` : `a IS NULL` 꼴에서 `a`가 `NULL` 인가의 여부이다.
* `IS NOT NULL` : `a IS NOT NULL` 꼴에서 `a`가 `NULL`이 아닌가의 여부이다.
* `LIKE` : `a LIKE b` 꼴에서 `a`가 `b`의 패턴에 부합하는가의 여부이다.
  * 패턴에서 `%`는 0개 이상의 아무 문자이다.
  * 패턴에서 `_`는 1개 이상의 아무 문자이다.
* `NOT LIKE` : `a NOT LIKE b` 꼴에서 `a`가 `b`의 패턴에 부합하지 않는가의 여부이다.
* `REGEXP` : `a REGEXP b` 꼴에서 `a`가 `b`의 정규 표현식(Regular Expression)을 만족하는가의 여부이다.
* `NOT REGEXP` : `a NOT REGEXP b` 꼴에서 `a`가 `b`의 정규 표현식(Regular Expression)을 만족하지 않는가의 여부이다.

<br><br>
